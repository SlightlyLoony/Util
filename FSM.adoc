= Finite State Machine
Tom Dilatush (tom@dilatush.com) +
V1.0, 2021-01-03
:toc:
:toc-placement!:
toc::[]

== What is a finite state machine, anyway?
Finite state machines, or FSMs, are abstract "machines" that at any given moment can be in exactly one of a finite number of states.  There's a very detailed https://en.wikipedia.org/wiki/Finite-state_machine[Wikipedia] article that will likely confuse you if you've never heard of FSMs before, but it's full of good information if you're at all familiar with them.  https://statecharts.github.io/what-is-a-state-machine.html[This article] describes event-driven FSMs, a particular kind of FSM, which is what this package provides.  The key elements:

=== States
The FSM has exactly one mutable variable: its current state.  In a completely generalized FSM, this variable could be anything at all.  In this package, the variable is an enum.  If the enum has 'n' values, then the FSM has 'n' possible states.  For instance, suppose you wanted to represent the states of a door opener - you might have OPEN, CLOSED, OPENING, CLOSING as the possible states.  The set of possible states is part of the definition of a given FSM.

=== Events
An FSM event is the software equivalent of an event in the real world: an event just means that something happened.  In this package, events are the combination of an enum that unambiguously identifies what kind of event we had, and an optional, arbitrary object containing additional information about the event.  In the door opener example above, we might have events REQUEST_OPEN, REQUEST_CLOSE, SENSED_OPEN, SENSED_CLOSE; none of them need any additional data.  In a different FSM you might have an event like ENGINE_RPM, and the data would represent the measurement (how many RPMs).  The set of possible events is part of the definition of a given FSM.

=== Transitions
An FSM transition is notion of the FSM changing from one state to another.  In this package, a transition is triggered by a specific event occurring while the FSM is in a specific state - so the tuple `<STATE, EVENT>` unambiguously identifies a transition.  Note that there may be at most one transition with any given `<STATE,EVENT>` tuples.  In most state machines, many possible such tuples do not identify a transition, either because they're not possible or because no action is needed.  For example, in our door opener example if the state was CLOSING, and we got a REQUEST_CLOSE event, we can ignore it.  Similarly, if the state was CLOSING we don't have to worry about getting an OPEN event, as it's not possible.

An FSM transition in this package is completely defined by four elements:

.FSM Transition Elements
|===
|*Name*|*Description*
|"from" state|The FSM state to transition from.  This state is part of the `<STATE,EVENT>` tuple that uniquely identifies a transition.
|event|The FSM event that triggers this transition.  This event is part of the `<STATE,EVENT>` tuple that uniquely identifies a transition.
|action|An optional function that is called during the transition.  The code in this function has access to the FSM itself, the optional global FSM context, and the states being transitioned from and to.
|"to" state|The FSM state to transition to.
|===

There is a minor variation on an FSM transition in this package that's worth discussing: you can define an FSM transition that doesn't change the FSM state at all (because the "from" state is the same as the "to" state).  While this may sound like an exercise in transitional futility, it's actually quite useful -- because the transition action is still called.  A transaction defined in this way essentially defines an "on event" action when that event occurs while the FSM is in that state.

=== Transition Actions
An FSM transition action is a function that is executed when an FSM transition is processed.  Any particular action can be associated with any number of FSM transitions.  The action's code can do anything at all.  In the door opener example above, we could imagine that when the door transitions from CLOSING to CLOSED, the associated action might turn on a red light to indicate that the door is closed.  Similarly, when the door transitions from OPENING to OPEN, the associated action might turn on a green light to indicate that the door is open.  While the door is in motion, perhaps the actions would turn on an amber light.

=== State Actions
In addition to the transition actions discussed above, you can also define "state actions" that are functions called either upon entry into a particular state, or on exit from a particular state.  These actions are very useful when you need an action that applies to _all_ transitions to a state, or _all_ transitions from a state.  Like the transaction actions, the state actions are optional.

== Some notes on threading...
The FSM can be configured to buffer events, though this is not required.  Let's consider the two cases separately:

* *Event buffering disabled*: In this case all invocations of an `onEvent()` method are synchronized on the FSM instance.  That guarantees that all the things that happen inside of event handling - including processing actions and event transforms - will happen in the caller's thread, but only in one thread at a time.
* *Event buffering enabled*: In this case all invocations of an `onEvent()` method are unsynchronized additions to the event queue, which is itself threadsafe.  The event queue is emptied by a single thread that's internal to the FSM, pulling events off the event queue and handling them sequentially, one at a time.

The FSM can also be configured to provide a simple event scheduling service.  If event scheduling is enabled, another thread (named `FSMEventScheduler`) is created and used by a single-threaded instance of `ScheduledExecutorService` that is internal to the FSM.  If event buffering is also enabled, then this thread does nothing but post events to the event queue.  However, if event buffering is _not_ enabled, then the scheduled events will be handled in the scheduler's thread - a good reason to be sure that actions and transforms do not block and do require excessive computation time.  What constitutes "excessive" is, of course, a function of the program using the FSM.

Ordinarily when using a scheduled executor service, cancelling scheduled tasks (in our case, posting events) is a potentially problematic exericise.  In particular, there is normally a "race condition", wherein one thread (such as the thread executing FSM actions) tries to cancel a scheduled task that has already executed.  In our case this circumstance is curable because FSM transitions occur, and FSM actions all execute, sequentially in a single thread (a necessity for the integrity of the FSM's state).  Our cure is to make the scheduled event itself cancellable (in addition to cancelling the scheduled task, if possible).  Thus the `scheduleEvent()` methods of the FSM return instances of a subclass of `FSMEvent` called `FSMCancellableEvent`.  The `onEventImpl()` method will simply ignore any cancelled events.  The result is that scheduled events can be cancelled without the usual risk of a race condition.

== FSM State
Most real-world implementations of an FSM require some state _other_ than the FSM's state.  The example program included in this package has two classes with FSMs, and one of them (in `EngineController`) has quite a few examples of such state.  For example, it needs to keep track of how many times it has tried to start the engine.  In several other places, it stores an `FSMCancellableEvent` in case the scheduled event in question needs to be cancelled.  In many real-world examples of FSMs, there will be dozens or even hundreds of pieces of state like this that need to be squirreled away somewhere until they're needed.  The FSM package gives you multiple places to do that.  Each of these places has its pros and cons, some of which may simply be matters of the programmer's taste or conventions.  None of them are required, all of them are freely available for you to use, and most of time it makes zero difference to the functioning of the FSM which one you choose.  Here are the mechanisms available to you:

=== Fields in the class containing the FSM
This is perhaps the most straightforward method of all, as it's the usual method of storing state in a Java class.  In the example program, the `EngineController` has a field `engineStartAttempts` that uses this method.  That field is used in two different FSM action methods.

=== FSM global context
The FSM global context is an arbitrary object, specified in the `FSMSpec` used to construct the FSM, that can contain any state you'd like.  The global context is available to any code that has access to the FSM instance (through the `getContext()` method), as well as FSM actions and FSM event transforms.  In the example program, the `EngineController` has an inner class `GlobalContext`, with a field `timeout` that shows this method in use; four different FSM action methods use that field.

=== FSM state context
The FSM state context is quite similar to the FSM global context, except there is a separate FSM state context for each FSM state, and each of these may be a different class (type).  FSM state contexts are accessible to any code that has access to the FSM instance (through the `getStateContext()` method) or the FSM state (through the `context` field).  FSM actions have two FSM state contexts available to them: for the FSM state being transitioned _from_, and the FSM state being transitioned _to_.  FSM event transforms have the FSM state context for the current state available to them.  In the example program, the `EngineController` has an inner class `StoppingContext`, with a field `timeout` that shows this method in use; two different FSM action methods use that field.

=== Properties of the FSM instance
The FSM class contains a `setProperty(name,value)` and `getProperty(name)` that do exactly what they look like they do.  The value of the property can be any object.  You can set and retrieve these properties from any code that has access to the FSM instance.

=== Properties of the FSM state
Each FSM state context can also contain a set of properties.  These properties are accessible through the `setProperty(name,value)` and `getProperty(name)` methods of the `FSMState` class.  They are also accessible from the FSM instance, via the `setProperty(state,name,value)` and `getProperty(state,name)` methods.  In the example program, the `EngineController` has two uses of this method, in the functions `actionInRange()` and `actionOutOfRange`.

== Scheduled Events and Timeouts
_Time_ is very important to many FSMs , especially those used to model things in the real world.  This package provides two closely-related services related to time.  These services are only available if event scheduling is enabled on the FSM instance.

* *Scheduled events*: The `scheduleEvent()` methods of the FSM provide a very simple way to schedule an event to occur at an arbitrary time in the future.  Any FSM event can be scheduled, and any scheduled event may be cancelled at any time prior to it being handled.  Because the FSM guarantees that events are processed one at time, that means that a scheduled event can be cancelled by any transition action or state action with no possibility that the cancellation will "miss".  The cancellation can even happen _after_ the scheduler has queued the event for processing and _still_ you can be certain it was really cancelled.  The `EngineController` in the example program has five different actions where events are scheduled; just look for the `scheduleEvent()` method calls.

* *Timeouts*: These are a particularly common need in many FSM implementations, and this package provides a simple and convenient way to use them.  There are two general scenarios when a timeout is useful.  The first is when you need to limit how long your FSM stays in some particular state.  In our example program, the `EngineController` allows 30 seconds for the engine to stabilize to 1800 RPM - if it takes any longer than that, the controller assumes the engine has failed.  In the transition action `actionStabilize`, the code sets that 30 second timeout by using the `setTimeout()` method on the FSM transition.  That timeout is automagically cancelled by the FSM if the FSM's state changes to _any_ other state.  The `EngineController` code doesn't have to worry about that at all.  The second general scenarios is when you need your FSM to stay in some particular state for a given amount of time.  In our example program, this is true of the `COOLING` state in the `EngineController`, which we need to stay in for 15 seconds, no matter what.  While we didn't use a timeout in that example (because we were showing examples of other FSM features), we _could_ have, and it would have been simpler than the scheduled event the example actually uses.

Under the covers, timeouts are actually implemented with scheduled events.

== Event Transformation

== FSM Spec

== FSM Validation
This package _validates_ the FSM's definition (the states, events, and transition definitions) before it will start up.  If the validation fails, the FSM will not be created.  The validation process checks for the following:

* *Duplicates*: No two transaction definitions may have the same transaction ID.
* *Stuck states*: States that cannot be left, because no transaction definitions includes them as `FROM_STATE`.
* *Isolated states*: States that cannot be entered, because no transaction definition includes them as `TO_STATE`.
* *Unused events*: Events that don't appear as `EVENT` in a transition definition, and also don't appear as an `EVENT` in an event transformation definition.


== How does it work?

....
    config.scenarios = makeMap( {
        interiorOverheatingScenario: {
            tempTest: makeEnabler( "Delay", { "_delay_": 5000, "value": 95.4 })
        }
    });
....


== Example program
Nothing works better for building understanding than an https://github.com/SlightlyLoony/Util/tree/master/src/main/Java/com/dilatush/util/fsm/example[example].  This example program uses two FSMs to implement the controls for a backup generator - the kind you install at your home to provide power if the grid power goes down.  A https://github.com/SlightlyLoony/Util/blob/master/src/main/Java/com/dilatush/util/fsm/example/GeneratorController.java[relatively simple FSM] controls the generator overall, and a https://github.com/SlightlyLoony/Util/blob/master/src/main/Java/com/dilatush/util/fsm/example/EngineController.java[much more complex FSM] controls the propane engine inside the generator.  Most likely you don't have a generator or the requisite electronics lying about to try this out, so we've provided simulators for both the engine and the bits of the generator external to the electronics.  The engine controller FSM contains 7 states with 13 different events, and shows examples of state contexts, timers, and event transforms.  The https://github.com/SlightlyLoony/Util/blob/master/src/main/Java/com/dilatush/util/fsm/example/ExampleTest.java[main class] for the example does very little:

....
public class ExampleTest {
    public static void main( final String[] _args ) throws InterruptedException, IOException {
        GeneratorSim        generator  = new GeneratorSim();
        Engine              engine     = new EngineSim();
        GeneratorController controller = new GeneratorController( generator, engine );
        generator.run();
    }
}
....
Just run that program, and the simulated generator and engine will start up, ready for you to play around with it.  Do a little debugging in the two classes with state machines, and I suspect you'll learn a bit.  One thing worth noting is that _everything_ in the state machine implementations is little bits of code, typically under 10 lines - very easy to understand and think about.  To this author's mind, that's one of the great advantages of FSMs - they naturally divide complex problems that are very hard to wrap your brain around into a series of small -- even _tiny_ -- problems that are quite understandable.

== Learning more...
The code for the FSM implementation can be found https://github.com/SlightlyLoony/Util/tree/master/src/main/Java/com/dilatush/util/fsm[here], and the example code https://github.com/SlightlyLoony/Util/tree/master/src/main/Java/com/dilatush/util/fsm/example[here].
