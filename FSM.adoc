= Finite State Machine
Tom Dilatush (tom@dilatush.com) +
V1.0, 2021-01-03
:toc:
:toc-placement!:
toc::[]

== What is a finite state machine, anyway?
Finite state machines, or FSMs, is an abstract "machine" that at any given moment can be in exactly one of a finite number of states.  There's a very detailed https://en.wikipedia.org/wiki/Finite-state_machine[Wikipedia] article that will likely confuse you if you've never heard of FSMs before, but it's full of good information if you're at all familiar with them.  https://statecharts.github.io/what-is-a-state-machine.html[This article] describes event-driven FSMs, a particular kind of FSM, which is what this package provides.  The key elements:

=== States
The FSM has exactly one mutable variable: its current state.  In a completely generalized FSM, this variable could be anything at all.  In this package, the variable is an enum.  If the enum has 'n' values, then the FSM has 'n' possible states.  For instance, suppose you wanted to represent the states of a door opener - you might have OPEN, CLOSED, OPENING, CLOSING as the possible states.  The set of possible states is part of the definition of a given FSM.

=== Events
An FSM event is the software equivalent of an event in the real world: an event means that something happened.  In this package, events are the combination of an enum that unambiguously identifies what kind of event we had, and an optional, arbitrary object containing additional information about the event.  In the door opener example above, we might have events REQUEST_OPEN, REQUEST_CLOSE, SENSED_OPEN, SENSED_CLOSE; none of them need any additional data.  In a different FSM you might have an event like RPM, and the data would represent the measurement (how many RPMs).  The set of possible events is part of the definition of a given FSM.

=== Transitions
An FSM transition is notion of the FSM changing from one state to another.  In this package, a transition is triggered by a specific event occurring while the FSM is in a specific state - so the tuple `<STATE, EVENT>` (which we'll call a transition ID, or TID) unambiguously identifies a transition.  Note that there may be at most one transition with any TID.  In most state machines, many possible TIDs are not identified at all, because they're not possible or because no action is needed.  For example, in our door opener example if the state was CLOSING, and we got a REQUEST_CLOSE event, we can ignore it.

=== Actions
An FSM action is some code that is executed when the FSM transitions from one state to another; any particular action is associated with one or more transitions.  The action's code can do anything at all.  In the door opener example above, we could imagine that when the door transitions from CLOSING to CLOSED, the associated action might turn on a red light to indicate that the door is closed.  Similarly, when the door transitions from OPENING to OPEN, the associated action might turn on a green light to indicate that the door is open.  While the door is in motion, perhaps the actions would turn on an amber light.

=== Transition Definition
A transition definition ties together the concepts just discussed.  In this machine, a transition definition (or TD) is a simple tuple `<FROM_STATE, EVENT, ACTION, TO_STATE>`.  The first two elements of the TD are simply the TID, unambiguously identifying the trigger for this transition.  The ACTION element is the action (code) associated with this transition; in this package it is optional (i.e., it can be `null`).  The last element - the TO_STATE - determines what the FSM's state will be _after_ the transition.  A list of these TDs specifies all of the possible transitions in the FSM, which is the same things as saying that it defines the _behavior_ of the FSM.  The set of defined transitions is part of the definition of a given FSM.

== Some notes on threading...
The FSM can be configured to buffer events, though this is not required.  Let's consider the two cases separately:

* *Event buffering disabled*: In this case all invocations of an `onEvent()` method are synchronized on the FSM instance.  That guarantees that all the things that happen inside of event handling - including processing actions and event transforms - will happen in the caller's thread, but only in one thread at a time.
* *Event buffering enabled*: In this case all invocations of an `onEvent()` method are unsynchronized additions to the event queue, which is itself threadsafe.  The event queue is emptied by a single thread that's internal to the FSM, pulling events off the event queue and handling them sequentially, one at a time.

The FSM can also be configured to provide a simple event scheduling service.  If event scheduling is enabled, another thread (named `FSMEventScheduler`) is created and used by a single-threaded instance of `ScheduledExecutorService` that is internal to the FSM.  If event buffering is also enabled, then this thread does nothing but post events to the event queue.  However, if event buffering is _not_ enabled, then the scheduled events will be handled in the scheduler's thread - a good reason to be sure that actions and transforms do not block and do require excessive computation time.  What constitutes "excessive" is, of course, a function of the program using the FSM.

Ordinarily when using a scheduled executor service, cancelling scheduled tasks (in our case, posting events) is a potentially problematic exericise.  In particular, there is normally a "race condition", wherein one thread (such as the thread executing FSM actions) tries to cancel a scheduled task that has already executed.  In our case this circumstance is curable because FSM transitions occur, and FSM actions all execute, sequentially in a single thread (a necessity for the integrity of the FSM's state).  Our cure is to make the scheduled event itself cancellable (in addition to cancelling the scheduled task, if possible).  Thus the `scheduleEvent()` methods of the FSM return instances of a subclass of `FSMEvent` called `FSMCancellableEvent`.  The `onEventImpl()` method will simply ignore any cancelled events.  The result is that scheduled events can be cancelled without the usual risk of a race condition.

== Event Transformation


== FSM Validation
This package _validates_ the FSM's definition (the states, events, and transition definitions) before it will start up.  If the validation fails, the FSM will not be created.  The validation process checks for the following:

* *Duplicates*: No two transaction definitions may have the same transaction ID.
* *Stuck states*: States that cannot be left, because no transaction definitions includes them as `FROM_STATE`.
* *Isolated states*: States that cannot be entered, because no transaction definition includes them as `TO_STATE`.
* *Unused events*: Events that don't appear as `EVENT` in a transition definition, and also don't appear as an `EVENT` in an event transformation definition.


== How does it work?

....
    config.scenarios = makeMap( {
        interiorOverheatingScenario: {
            tempTest: makeEnabler( "Delay", { "_delay_": 5000, "value": 95.4 })
        }
    });
....


== Example program
Nothing works better for building understanding than an https://github.com/SlightlyLoony/Util/tree/master/src/main/Java/com/dilatush/util/fsm/example[example].  This example program uses two FSMs to implement the controls for a backup generator - the kind you install at your home to provide power if the grid power goes down.  A relatively simple FSM controls the generator overall


== Learning more...
The code for the FSM implementation can be found https://github.com/SlightlyLoony/Util/tree/master/src/main/Java/com/dilatush/util/fsm[here], and the example code https://github.com/SlightlyLoony/Util/tree/master/src/main/Java/com/dilatush/util/fsm/example[here].
