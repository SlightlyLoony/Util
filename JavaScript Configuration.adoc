= JavaScript Configuration Support
Tom Dilatush (tom@dilatush.com) +
V1.0, 2021-01-07
:toc:
:toc-placement!:
toc::[]

== What is this JavaScript configuration stuff, anyway?
I have been using JSON configuration files for some time now.  They are convenient in the sense that relatively simple code can read them into a Java program.  At that point Java code can validate the configuration values, and use them directly.  However, these JSON configurations have some drawbacks (see list below).  The most obvious alternative is plain text files, as are used by very many Unix/Linux programs.  They have drawbacks as well (also below)!  Here are the main drawbacks of those two approaches for configuration files, starting with the worst in my assessment.
[start=1]
. *No comments.*  JSON (standard JSON, at least) cannot have comments at all.  Having a configuration file with no comments means that every time I forget what a parameter does, or what its valid values are (i.e., almost every time I use it!), I have to go back to the Java code to figure it out.  It's like a reverse-engineering exercise to make even the simplest change.  The Unix-style text files _do_ allow comments, which is great.
. *Standardization.*  JSON is a standard; that's one thing I really like about it.  The Unix/Linux configuration files are similar, but definitely not a standard format.  If you have spent any time at all administering a Unix or Linux, you'll know exactly what I mean.  The lack of standardization makes the modifying the files error prone and difficult to remember.
. *Only literals of limited type.*  If all configuration entries were constants, and were strings, numbers, or booleans, this would not be much of an issue.  There are times, however, when it would be very convenient to have an arbitrary type in the configuration file -- such as an `Enum` value, or perhaps a `URL` instance.  The best that JSON or plain text files can provide is a string that your program can convert into one of those objects - but then your code has to do that work, including validation of it.  There are also times when it would be convenient to be able to determine a configuration value programmatically.  A simple example: suppose you have a configuration value that represents time in milliseconds - and you want to configure 14 days.  You _could_ drag out your calculator, figure out the answer (it's 1,209,600,000), and put that in your configuration file.  But then when you look at the configuration file later you'll have no idea what that giant number means.  How much nicer it would be to write something like this:
....
time = 14 * 24 * 60 * 60 * 1000 // number of milliseconds in 14 days...
....
I had read several articles online about using executable code for configuration.  The more I thought about using JavaScript for configuration, the more I liked it:
[start=1]
. *JavaScript has comments.*  Nice, standard comments, both block ( `+/* ... */+` ) and line ( `\\ ...` ).  What more could I possibly want?
. *JavaScript is standard.*  There aren't 53 flavors of JavaScript.  There's just one, evolving in a backwards-compatible way.  Perfect!
. *JavaScript is a programming language.*  That means my JavaScript configuration files wouldn't be limited to literals of a few types.  Code can construct configuration values, as in the trivial example above.  It also turns out that with Java's built-in JavaScript engine (https://en.wikipedia.org/wiki/Nashorn_(JavaScript_engine)[Nashorn]), the JavaScript configuration file could even create and manipulate native Java objects.  Nashorn has been removed from the most recent versions of Java, but I'm expecting a suitable replacement to come along, possibly through the https://en.wikipedia.org/wiki/GraalVM[GraalVM project].  Meantime, like many Java programmers, I'm using Java 8 (which does have Nashorn) and I have no immediate plans to start using later Java versions.

== How does it work?
Here's an example of the JavaScript configuration in actual use:
....
    // get our configuration...
    AConfig.InitResult ir = AConfig.init( Config.class, "configuration.js" );

    // if our configuration is not valid, just get out of here...
    if( !ir.valid ) {
        LOGGER.severe( "Aborting; configuration is invalid\n" + ir.message );
        System.exit( 1 );
    }

    // get our valid configuration...
    Config config = (Config) ir.config;
....
Let's take this one bit at a time:
....
    // get our configuration...
    AConfig.InitResult ir = AConfig.init( Config.class, "configuration.js" );
....
The `AConfig.init( class, filename)` method creates an instance of the given class (which must be a subclass of `AConfig`, and must have a no-args constructor) and then initializes it with the JavaScript script in the given file.  Its return value is a tuple that contains the boolean `valid`, a `message` explaining what caused problems if the result was invalid, and `config`, which is the instantiated and initialized configuration, if the configuration was valid.
....
    // if our configuration is not valid, just get out of here...
    if( !ir.valid ) {
        LOGGER.severe( "Aborting; configuration is invalid\n" + ir.message );
        System.exit( 1 );
    }
....
Here we're just checking for an invalid configuration file.  If it _was_ invalid, it just logs the message about any problems that were found, and exits.
....
    // get our valid configuration...
    Config config = (Config) ir.config;
....
And finally, we're getting that nice, valid configuration.  What's in that configuration object?  Whatever you want, and whatever your program needs!  Here's an example:
....
    /**
     * Validatable POJO for {@link TempReader} configuration (see {@link TempReader#TempReader(Config)}).
     */
    public static class Config extends AConfig {

        /**
         * The interval between temperature readings, in milliseconds.  Valid values are in the
         * range [100..600,000] (0.1 second to 10 minutes).
         */
        public  long intervalMS = 250;

        /**
         * The interval between error events, in milliseconds.  Valid values are in the
         * range [intervalMS..600,000].
         */
        public  long errorEventIntervalMS = 10000;

        /**
         * An instance of the class that implements {@link ErrorCalc}, for the noise filter.
         */
        public NoiseFilter.NoiseFilterConfig noiseFilter = new NoiseFilter.NoiseFilterConfig();


        /**
         * Verify the fields of this configuration.
         */
        @Override
        public void verify( final List<String> _messages ) {
            validate( () -> ((intervalMS >= 100) && (intervalMS <= 1000 * 60 * 10)), _messages,
                    "Temperature Reader interval out of range: " + intervalMS );
            validate( () -> ((errorEventIntervalMS >= intervalMS)
                            && (errorEventIntervalMS <= 1000 * 60 * 10)), _messages,
                    "Temperature Reader error event interval is out of range: " + errorEventIntervalMS );
            noiseFilter.verify( _messages );
        }
    }
....
The first two fields defined are simple values, but the third (`NoiseFilter.NoiseFilterConfig noiseFilter`) is itself another subclass of `AConfig`.  This ability to create a hierarchy of `AConfig` instances is a key feature of the `AConfig` class.  It allows configurations (like the one above for `NoiseFilter`) to be defined a single time, typically as an inner class of the class needing the configuration -- and then be composed (as in the `TempReader` configuration above) as part of a larger and more complex configuration.

The `verify()` method is another key feature of the `AConfig` class.  It's job is to verify the validity of the configuration values (after the script initializes them, of course).  For fields with simple values, this is done by calling the `validate()` method (which is defined in `AConfig`).  The first argument to `validate()` is a lambda that is a validity test; it returns `true` if the result was valid.  The second argument is a list of error messages, and the third argument is a message to add to the error messages if the validity test returned `false`.  There are no particular limits to what the validity test checks, but as the example shows they naturally tend to be simple and readable.   Note in the example above that when one of the fields is itself an `AConfig` subclass, _its_ `verify()` method is also called.  This is how a hierarchy of `AConfig` instances gets validated.

So what does the configuration script look like for this?  Here's an example that corresponds to the `AConfig` subclass above:
....
function init( config ) {
    /*
     * Temperature Reader configuration.
     */

    // The interval between temperature readings, in milliseconds.  Valid values are in the
    // range [100..600,000] (0.1 second to 10 minutes).
    config.intervalMS = 250;

    // The interval between error events, in milliseconds.  Valid values are in the
    // range [intervalMS..600,000].
    config.errorEventIntervalMS = 5 * 60 * 1000;  // five minutes...

    // The number of samples (history) to keep in the filter.  Valid values are 2 or greater.
    config.noiseFilter.numSamples = 41;

    // An instance of the class that implements ErrorCalc, for the noise filter.
    config.noiseFilter.errorCalc
      = new (Java.type( 'com.dilatush.util.noisefilter.MedianErrorCalc' ))();

    // The maximum number of samples that may be ignored by this filter, as a fraction of the number of
    // samples.  Valid values are in the range [0..1].
    config.noiseFilter.maxIgnoreFraction = 0.25;

    // The maximum total error of the samples that may be ignored by this filter, as a fraction
    // of the total error of all the samples in this filter.  Valid values are in the range of [0..1].
    config.noiseFilter.maxTotalErrorIgnoreFraction = 1.0;

    // The minimum value of the error for any sample to be ignored.  This value must be non-negative.
    config.noiseFilter.minSampleErrorIgnore = 0.75;  // in degree C
}
....
The `init( config )` function _must_ be defined in the JavaScript configuration file of the name that was an argument to `AConfig.init()`.  That function is called by `AConfig.init()`.  The `config` object is the freshly created instance of the `AConfig` subclass that was an argument to `AConfig.init()`.  The function you define in JavaScript is what does the work of initializing that `AConfig` subclass instance.  When you modify `config` in JavaScript, it's actually the Java `AConfig` subclass instance that's being modified.

Note that your script may contain anything you want outside of that `init( config )` function.  You can define classes, have other functions, etc.

Now look a bit more closely at the example `init( config )` function above.  Ah, look at the comments!  I love comments in configuration files.  Some fields here are initialized as the result of expressions - so nice!  The last five fields are all actually initializing fields _inside_ the `NoiseFilter.NoiseFilterConfig` field.  This is how your script can initialize a hierarchy of `AConfig` subclasses.  The initialization of `config.noiseFilter.errorCalc` is an example of the configuration file creating a native Java object, using a feature of the Nashorn JavaScript engine.

== Learning more details...
The entire JavaScript configuration system is contained in a single class: https://github.com/SlightlyLoony/Util/blob/master/src/main/Java/com/dilatush/util/AConfig.java[AConfig], which is under 200 lines long.  Take a look!