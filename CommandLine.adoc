= Command Line Argument Interpreter Package
Tom Dilatush (tom@dilatush.com) +
V1.0, 2021-01-03
:toc:
:toc-placement!:
toc::[]

== What is a Command Line Argument Interpreter?
If you're writing a command line program (or server daemon), you're most likely going to want to provide for command line arguments.  For example:
....
myapp -c=12 -q --site https://comic.com ~/myfile.txt
....
This might be a command that reads the site https://comic.com (the `--site https://comic.com`) twelve times (the `-c=12`), does it quietly (the `-q`), and puts the result in ~/myfile.txt (the `~/myfile.txt`).  This is all very standard in the Unix/Linux world, and to some extent even under Windows.  But actually _writing_ the code to interpret all that is a pain in the patoot - especially if you want decent error checking, the expected help, etc.

The whole purpose of this package is to make that effort easier.  _Much_ easier.  Also less error-prone.

== The notion of "arguments"...
In the example immediately above, we see four arguments (the stuff following `myapp`):

[start=1]

. The `-c=12` is an _optional_ argument with the short name `c` and an argument parameter `12`.  The `=` separates the short argument name from its parameter.  This parameter looks like a number to us, and the program needs to use it as a number, but on the command line it's two text characters: '1' and '2'.  Somewhere inside the program it has to be parsed and translated into the number 12.

. The `-q` is also an _optional_ argument, but with no parameter.  We call that a _binary_ optional argument, and it
has the value _true_ if it is present on the command line, and _false_ otherwise.

. The `--site https://comic.com` is yet another optional argument, but this time with a long name `--site`.  It has an argument parameter (the `https://comic.com`).  Note that the paramter immediately follows the long argument name, but is separated from it by a space (not the `=` we saw with the first argument).  In this case the parameter is a string, but it's obvious to a human reader that that string is a URL - and that's also what the program expects.  Somewhere inside the program that string has to be parsed, validated, and converted to a URL.

. The `~/myfile.txt` is a path to a file, and there's no optional argument name before it.  That's because it's not an optional argument at all, but rather a _positional_ argument.  The meaning of a positional argument depends on exactly where it is on the command line, ignoring any optional arguments.  In this case it's the first (and only) positional argument.

From these observations we can form some general rules for arguments:

* Short optional argument names are just a single character long, preceded by a single hyphen ("-").  They _may_ have a parameter, which can be any string that does not contain unquoted whitespace.  If an optional argument with a short name has parameter, the parameter is indicated by an equals sign ("=") immediately following the short character name, with the parameter string itself immediately following the equals sign.  The `-c=12` above is an example of that.  We could also have written the two arguments with short names above as `-qc=12` - multiple arguments with short names can be specified after a single hyphen ("-"), so long as only the last one has a parameter.  Any non-whitespace character may be used as a short argument name, with the exceptions of "-" and "=" (and we hope the reason for those exceptions is obvious!).  Conventionally the short argument name characters are in the range [a-zA-Z0-9?], though that is not required.

* Long optional argument names can be one or more characters long, preceded by a double hyphen ("--").  They _may_ have a parameter, which (as above) can be any string that does not contain unquoted whitespace.  This parameter, if present, is separated from the long name by whitespace.  Any non-whitespace characters may be used in a long argument name, with the exceptions of "-" and "=" (and again we hope the reason for those exceptions is obvious!).  Conventionally the long  argument names are comprised of characters in the range [a-zA-Z0-9_], though that is not required.

* Positional arguments have no names at all; how they are interpreted depends entirely on their relative position on the command line, after ignoring any optional arguments.  Note that while optional arguments are conventionally written _before_ the positional arguments, this is not actually required.  For instance, we could have written our example as +
`myapp -c=12 -q ~/myfile.txt --site https://comic.com` +
without any change in its meaning.  We could _not_ have written it as +
`myapp -c=12 -q --site ~/myfile.txt https://comic.com` +
because then the `--site` argument would have interpreted the `~/myfile.txt` as a URL, which is not likely to work well - and the `https://comic.com` would have looked like the positional argument for a file name, and that also would work quite poorly.







