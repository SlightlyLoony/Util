= Command Line Argument Interpreter Package
Tom Dilatush (tom@dilatush.com) +
V1.0, 2021-01-03
:toc:
:toc-placement!:
toc::[]

== What is a Command Line Argument Interpreter?
If you're writing a command line program (or server daemon), you're most likely going to want to provide for command line arguments.  For example:
....
myapp -c=12 -q --site https://comic.com ~/myfile.txt
....
This might be a command that reads the site https://comic.com (the `--site https://comic.com`) twelve times (the `-c=12`), does it quietly (the `-q`), and puts the result in ~/myfile.txt (the `~/myfile.txt`).  This is all very standard in the Unix/Linux world, and to some extent even under Windows.  But actually _writing_ the code to interpret all that is a pain in the patoot - especially if you want decent error checking, the expected help, etc.

The whole purpose of this package is to make that effort easier.  _Much_ easier.  Also less error-prone.

== The notion of "arguments"...
In the example immediately above, we see four arguments (the stuff following `myapp`):

[start=1]

. The `-c=12` is an _optional_ argument with the short name `c` and an argument parameter `12`.  The `=` separates the short argument name from its parameter.  This parameter looks like a number to us, and the program needs to use it as a number, but on the command line it's two text characters: '1' and '2'.  Somewhere inside the program it has to be parsed and translated into the number 12.

. The `-q` is also an _optional_ argument, but with no parameter.  We call that a _binary_ optional argument, and it
has the value _true_ if it is present on the command line, and _false_ otherwise.

. The `--site https://comic.com` is yet another optional argument, but this time with a long name `--site`.  It has an argument parameter (the `https://comic.com`).  Note that the paramter immediately follows the long argument name, but is separated from it by a space (not the `=` we saw with the first argument).  In this case the parameter is a string, but it's obvious to a human reader that that string is a URL - and that's also what the program expects.  Somewhere inside the program that string has to be parsed, validated, and converted to a URL.

. The `~/myfile.txt` is a path to a file, and there's no optional argument name before it.  That's because it's not an optional argument at all, but rather a _positional_ argument.  The meaning of a positional argument depends on exactly where it is on the command line, ignoring any optional arguments.  In this case it's the first (and only) positional argument.

From these observations we can form some general rules for arguments:

* Short optional argument names are just a single character long, preceded by a single hyphen ("-").  They _may_ have a parameter, which can be any string that does not contain unquoted whitespace.  If an optional argument with a short name has parameter, the parameter is indicated by an equals sign ("=") immediately following the short character name, with the parameter string itself immediately following the equals sign.  The `-c=12` above is an example of that.  We could also have written the two arguments with short names above as `-qc=12` - multiple arguments with short names can be specified after a single hyphen ("-"), so long as only the last one has a parameter.  Any non-whitespace character may be used as a short argument name, with the exceptions of "-" and "=" (and we hope the reason for those exceptions is obvious!).  Conventionally the short argument name characters are in the range [a-zA-Z0-9?], though that is not required.

* Long optional argument names can be one or more characters long, preceded by a double hyphen ("--").  They _may_ have a parameter, which (as above) can be any string that does not contain unquoted whitespace.  This parameter, if present, is separated from the long name by whitespace.  Any non-whitespace characters may be used in a long argument name, with the exceptions of "-" and "=" (and again we hope the reason for those exceptions is obvious!).  Conventionally the long  argument names are comprised of characters in the range [a-zA-Z0-9_], though that is not required.

* Positional arguments have no names at all; how they are interpreted depends entirely on their relative position on the command line, after ignoring any optional arguments.  Note that while optional arguments are conventionally written _before_ the positional arguments, this is not actually required.  For instance, we could have written our example as +
`myapp -c=12 -q ~/myfile.txt --site https://comic.com` +
without any change in its meaning.  We could _not_ have written it as +
`myapp -c=12 -q --site ~/myfile.txt https://comic.com` +
because then the `--site` argument would have interpreted the `~/myfile.txt` as a URL, which is not likely to work well - and the `https://comic.com` would have looked like the positional argument for a file name, and that also would work quite poorly.

== How Does the Command Line Interpreter package work?
It's all well and good to have a command line interpreter, but if you're going to make use of it then you'll have to understand just a bit about how it works!
[start=1]
. *Defining*: Your application must _define_ the expected arguments (both optional and positional) on the command line.  This is quite straightforward in concept, though there are lots of details.  Basically you create an argument definition (an instance of ArgDef or one of its many subclasses) for each argument your application needs to understand, and then you add those argument definitions to a command line definition (an instance of CommandLine).
. *Parsing*: This is very simple: you pass the command line arguments your application got in its main() method to the parse() method of your CommandLine instance.  If the result is valid, it contains the values of all the defined arguments (including a default value if the argument wasn't present on the command line).  If the result is invalid, it contains an explanatory error message.
. *Using*: If the result of parsing was valid, then your application can retrieve (by name) each argument's value.  That's the end goal of this package - a simple and straightforward way to use the command line arguments.

== Argument Definitions
Getting these right are the key to using this package effectively.  This package includes a selection of argument definition classes (subclasses of ArgDef) that are useful for particular kinds of arguments.  There are two main "families" of these classes, one for positional arguments and the other for optional arguments.  The class hierarchy looks like this:
....
    ArgDef   // the abstract base class for all argument definitions...
        APositionalArgDef   // the abstract base class for all positional argument definitions...
            (all subclasses for positional argument definitions)
        AOptionalArgDef   // the abstract base class for all optional argument definitions...
            (all subclasses for optional argument definitions)
....
If you look at the source for the concrete subclasses, you'll note that all they do is to set the values of fields and do some error checking.  In other words, they're very simple - and if you need one of your own, you shouldn't hesitate to write it!

Something worth noting is that the fields of the argument definition abstract base classes are all public and non-final - in other words, they're mutable by your application's code.  That means you can create an argument definition using one of the concrete argument definition subclasses, and then modify one of those fields in your application's code.  This feature makes it straightforward to handle a one-off extension of an existing subclass.

The fields of ArgDef:

- *referenceName*: This is the name your application's code uses to refer to a particular argument.  It can be any string, so long as that string is unique amongst all the arguments defined for a given application.  For the most part this name is invisible to your application's user, but there is one important exception to this: when this package creates an error message for a positional field, it uses the reference name in the message.  Therefore, at least for positional arguments, you should choose a meaningful name.

- *summary*: A short help message for this field, which will be included in the summary help.  There are no rules for the length of this string, though ideally it will fit on a single line.

- *detail*: A longer, more detailed help message for this field, which will be included in the detailed help.

- *maxAllowed*: The maximum number of times this argument may appear on the command line.  Zero is a special value that indicates there is no limit.  Most of the time this value will be a 1 (one), but there are some important exceptions.  For instance, a positional argument for a file name might be globbed, and therefore could have any number of appearances.  Another example might be an optional argument that increases the verbosity of an application's output more and more the more times it appears, up to some limit.  This is often seen as the short argument "-v", allowed to appear four or five times.

- *type*: The Java class object for the type of the argument's value.  This _could_ be String.class for every argument, which is how the argument parameters appear on the command line.  This would be a shame, however, because it would miss a lot of the power of this package.  Every argument definition includes an optional ParameterParser instance.  These are discussed in detail in their own section, but basically they translate the paramater string on the command line into a value of whatever type you want.  These could be numbers, InetAddress instances, File instances ... or whatever.  This built in translation capability makes your application code simpler - always a good goal!

- *defaultValue*: The default value for this argument if it does not appear.  This is mainly useful for optional arguments; it is the value of the argument in the results if the command does _not_ appear on the command line.  However, it is possible for a positional argument to be optional, and in that case the default value will also become the value of that argument if it does _not_ appear on the command line.

....
public ParameterMode      parameterMode;     // whether a parameter value is disallowed, optional, or mandatory
public ParameterValidator validator;         // the validator for this argument's parameter
public ParameterParser    parser;            // the parser for this argument's parameter
public InteractiveMode    interactiveMode;   // whether a prompt for this parameter value is disallowed, plain text, or obscured text
public String             prompt;            // if interactive is allowed, the prompt for the value
....

There are two arguments that are implicitly defined:

- *Single hyphen ("-")*: When a single hyphen appears as an argument (white space before and after) on the command line, it has a special meaning: that the next argument after it will be interpreted as a positional argument, and not as an optional argument.  This is useful only in a very limited case: when a positional argument happens to start with a hyphen.  Consider a contrived simple case where an application echoes the positional command line arguments: `myecho abc def`.  This would work as expected, but `myecho ab --cd ef` would not, as the `--cd` would appear to be an optional argument.  In this case, `myecho ab - --cd ef` would fix the problem.

- *Double hyphen ("--")*: This is similar to the single hyphen, except that _all_ following arguments will be interpreted as positional arguments, and not as optional arguments.  So, for example, `+myecho -- -ab --cd+` would work as expected.

== Parameter Parsers

== Parameter Validators

== Getting parameter values from environment variables
Sometimes getting a value from the command line (or a shell script) is not really what you want.  One classic example is a password - you really don't want someone to see it, and you certainly don't want it in your shell script.  Another example might be the path to some file needed in a shell script, where the path might be different on different machines, but it would be nice to have a single shell script.  You _could_ enter the path as an argument every time you ran the script, but that's a pain no matter how you slice it.  Environment variables are a nice solution to both issues, if only we could use their contents as parameter values.  And you can!

This package looks at any parameter value (whether on the command line, a default value, or an absent value) to see if it is in the form "%NAME%", and if so, it interprets "NAME" as the name of an environment variable, and substitutes the contents of that environment variable as the value of that parameter.  Note that the first and last characters of the parameter value must be a "%", and _everything_ between them is used as the environment variable name.

For the two examples given above, this gives you a nice solution.  For the password, you could define an optional argument with an optional parameter - and a default value like "%PASSWORD%".  This way if you leave the parameter off the command line, the default value will be extracted from the environment variable PASSWORD.  Similarly, for the file path example you could define a mandatory argument with an optional parameter - and an absent value like "%IMPORTANT_FILE_PATH%".  In this case if the argument isn't specified on the command line at all, it will get its value from IMPORTANT_FILE_PATH.  If the argument _is_ specified on the command line, then its value will be equal to the parameter entered by the user.

If a parameter value specifies an environment variable, but that variable does not exist, then the parameter value is the empty string ("").

== Getting parameter values from files
In a manner very similar to the way this package can get parameter values from environment variables (as described above), it can also get parameter values from text files.  To do this, any parameter value (whether on the command line, a default value, or an absent value) can be in the form "+#FILE_PATH#+".  In this case the FILE_PATH is treated as a (wait for it!) file path, and if there's a readable file at that path its contents are used as the parameter value.  Simple!  If the file path doesn't resolve to a readable file, then the paramter value is the empty string ("").